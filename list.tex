% #1 name (allows quicker access), #2 comma-separated elements
% note: your name (#1) must be a valid command sequence to work!
\def\chr@list#1#2{%
   \chr@tempcount=\z@
   \def\chr@listcheck{#2}%
   \ifx\chr@listcheck\chr@empty\else
      \chr@for\chr@elem:={#2}\do{%
            % you gotta love tex :3 we have to expand \chr@elem once to persist the content
            \expandafter\expandafter\expandafter\def
               \expandafter\csname\expandafter#1@\expandafter\the\expandafter\chr@tempcount
               \expandafter\endcsname\expandafter{\chr@elem}%
            \chr@step\chr@tempcount
      }%
   \fi
   \expandafter\def\csname#1\endcsname##1{\csname#1@##1\endcsname}%
   \expandafter\edef\csname#1length\endcsname{\the\chr@tempcount}%
   \chr@verbose{Created list #1 with \the\chr@tempcount\space element(s).}%
}

% FIXME: we should just use the current listname but is it worth the register and scoping?
\def\chr@break{\chr@tempcountc=100000}

% #1 name, #2 and #3 are the indices
\def\chr@list@swap#1#2#3{%
   % the worse, the cake is a lie shuffle!
   \chr@list@let\chr@swp@temp=#1[#2]%
   \expandafter\chr@list@let\csname #1@#2\endcsname=#1[#3]%
   \expandafter\let\csname #1@#3\endcsname=\chr@swp@temp
}

\def\chr@list@log#1{\begingroup
   \chr@log{Dumping List #1}%
   \ifnum\csname#1length\endcsname=\z@\relax
      \chr@log{Empty List}%
   \else
      \chr@list@iter\elem:=#1\do{%
         \chr@log{\elem}%
      }%
   \fi
   \chr@log{End of List #1}%
\endgroup}

% collects the first #3 elements of the list with name #2 in #1
\def\chr@list@to@string#1#2#3{\begingroup
   \global\let#1=\chr@empty
   \chr@tempcount=\z@
   \ifnum\csname#2length\endcsname=\z@\relax \else
      \chr@list@iter\chr@elem:=#2\do{%
         \ifnum\chr@tempcount=\z@\relax
            \expandafter\chr@gapp\expandafter#1\expandafter{\chr@elem}%
         \else
            \expandafter\chr@gapp\expandafter#1\expandafter{\expandafter,\chr@elem}%
         \fi
         \chr@step\chr@tempcount
         \ifnum\the\chr@tempcount<#3\else
            \chr@break
         \fi
      }%
   \fi
   \chr@verbose{List #2 to string: '#1'}%
\endgroup}

% similar to \chr@for but does the expansion for the list under the hood :3
\def\chr@list@iter#1:=#2\do#3{%
   \chr@tempcountc=\z@
   \edef\chr@length{\csname#2length\endcsname}%
   \loop
      \expandafter\let\expandafter#1\expandafter=\csname#2@\the\chr@tempcountc\endcsname
      #3%
      \chr@step\chr@tempcountc
      % automatic break insertion
      \ifnum\chr@tempcountc<\chr@length
   \repeat
}

% get the #3th element of list #2 and store it into #1
\def\chr@list@let#1=#2[#3]{%
   \expandafter\let\expandafter#1\expandafter=\csname#2@#3\endcsname
}
\def\chr@list@set#1[#2]=#3;{%
   \expandafter\def\csname#1@#2\endcsname{#3}%
}
\def\chr@list@eset#1[#2]=#3;{%
   \expandafter\edef\csname#1@#2\endcsname{#3}%
}
\def\chr@list@eget#1=#2[#3]{%
   \expandafter\edef\expandafter#1\expandafter{\expandafter\expandafter\expandafter\chr@strip@meaning\expandafter\meaning\csname#2@\the\chr@tempcount\endcsname}
}

% TODO: optimize?
\def\chr@list@concat#1#2#3{%
   \chr@list{#1}{}%
   \def\chr@tmp@listname{#1}%
   \ifnum\csname#2length\endcsname=\z@\relax \else
      \chr@list@iter\chr@elem:=#2\do{%
         \expandafter\chr@list@append\expandafter{\expandafter\chr@tmp@listname\expandafter}\expandafter{\chr@elem}%
      }%
   \fi
   \ifnum\csname#3length\endcsname=\z@\relax \else
      \chr@list@iter\chr@elem:=#3\do{%
         \expandafter\chr@list@append\expandafter{\expandafter\chr@tmp@listname\expandafter}\expandafter{\chr@elem}%
      }%
   \fi
   \chr@verbose{Concatenated lists #2 and #3 into #1 (length: \csname#1length\endcsname).}%
}

% names of both lists, expands to \chr@true if equal, \chr@false otherwise
% compares on the values as stored in the list
\def\chr@list@equal#1#2{\begingroup
   \chr@verbose{Check if lists #1 and #2 are equal.}%
   \chr@tempcount=\csname#1length\endcsname\relax
   \chr@tempcountb=\csname#2length\endcsname\relax
   \ifnum\chr@tempcount=\chr@tempcountb
      \global\chr@result@true
      \chr@tempcount=\z@
      % allow loop
      \chr@tempif@true
      \loop
         \chr@list@eget\@chr@left=#1[\the\chr@tempcount]%
         \chr@list@eget\@chr@right=#2[\the\chr@tempcount]%
         % compar
         \ifx\@chr@left\@chr@right
            \chr@verbose{Lists are equal at index \the\chr@tempcount.}%
         \else
            \chr@verbose{Lists are not equal at index \the\chr@tempcount\space (\@chr@left\space vs. \@chr@right).}%
            \global\chr@result@false
            \chr@tempif@false
         \fi
         % automatic break insertion
         \chr@step\chr@tempcount
         \ifnum\chr@tempcount<\csname#1length\endcsname \else \chr@tempif@false \fi
         \ifchr@tempif@
      \repeat
      \chr@verbose{Lists are \ifchr@result@\else not\space\fi equal.}%
   \else
      \chr@verbose{Different lengths (\the\chr@tempcount\space vs. \the\chr@tempcountb).}%
      \global\chr@result@false
   \fi
   \aftergroup\ifchr@result@
\endgroup}

% #1 name of list, #2 element to append
\def\chr@list@append#1#2{%
   \chr@tempcount=\csname#1length\endcsname
   \expandafter\gdef\csname#1@\the\chr@tempcount\endcsname{#2}%
   \expandafter\xdef\csname#1length\endcsname{\the\chr@tempcount}%
   \chr@step\chr@tempcount
}
% #1 name of list, #2 index to delete
\def\chr@list@delete#1#2{%
   % TODO: check for if last element => pop
   % otherwise replace with \main{next-idx}
}
