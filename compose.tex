% list name of solvers list
% :: solvers -> solver
\def\chr@compose#1{%
   \edef\solvernames{#1}%
   \chr@program@set{composite_solver}##1{%
      \chr@list@to@string\chr@temp@list{##1}{\csname##1length\endcsname}%
      \chr@verbose{running composite solver with '##1' (content: [\chr@temp@list])}%
      \chr@list@concat{chr@list@return}{##1}{@empty@list}%
      % iterate over every solver
      \chr@list@iter\chr@s:=\solvernames\do{%
         % contract: every solver must store its provider in \chr@toreturn
         \chr@s % TODO: just get the rule fn?
         \chr@program@get{chr@toreturn}{##1}
         % compare if the constraints have changed => did this solver make us happy?
         \chr@list@equal{chr@constraints}{chr@list@return} \else%
            % if so, break, this solver is nice!
            \chr@break
         \fi
      }%
      % TODO: maybe just keep toreturn in local register?
      % chr@constraints
   }
   % technically it is up to the caller to do that :eyes:
   % on call, we simply assume, that '\constraintsname' is set
   % \chr@program@get{composite_solver}%
}

\def\chr@compose@inline#1{%
   % TODO: support nesting?
   \chr@list{\chr@current @solvers}{#1}%
   \chr@compose{\chr@current @solvers}%
}
